//! SIMD-accelerated sRGB ↔ linear conversion.
//!
//! This module provides high-performance conversion functions using AVX2/SSE SIMD
//! instructions via the `wide` crate with runtime CPU feature detection.
//!
//! # API Overview
//!
//! ## x8 Functions (process 8 values at once)
//! - [`srgb_to_linear_x8`] - f32x8 sRGB → f32x8 linear
//! - [`linear_to_srgb_x8`] - f32x8 linear → f32x8 sRGB
//! - [`srgb_u8_to_linear_x8`] - \[u8; 8\] sRGB → f32x8 linear
//! - [`linear_to_srgb_u8_x8`] - f32x8 linear → \[u8; 8\] sRGB
//!
//! ## Slice Functions (process entire slices)
//! - [`srgb_to_linear_slice`] - &mut \[f32\] sRGB → linear in-place
//! - [`linear_to_srgb_slice`] - &mut \[f32\] linear → sRGB in-place
//! - [`srgb_u8_to_linear_slice`] - &\[u8\] sRGB → &mut \[f32\] linear
//! - [`linear_to_srgb_u8_slice`] - &\[f32\] linear → &mut \[u8\] sRGB

use multiversed::multiversed;
use wide::{CmpLt, f32x8};

use crate::fast_math::pow_x8;

// sRGB transfer function constants (IEC 61966-2-1)
const SRGB_LINEAR_THRESHOLD: f32x8 = f32x8::splat(0.039_293_37);
const LINEAR_THRESHOLD: f32x8 = f32x8::splat(0.003_041_282_6);
const LINEAR_SCALE: f32x8 = f32x8::splat(1.0 / 12.92);
const SRGB_OFFSET: f32x8 = f32x8::splat(0.055);
const SRGB_SCALE: f32x8 = f32x8::splat(1.055);
const TWELVE_92: f32x8 = f32x8::splat(12.92);
const ZERO: f32x8 = f32x8::splat(0.0);
const ONE: f32x8 = f32x8::splat(1.0);
const U8_MAX: f32x8 = f32x8::splat(255.0);
const HALF: f32x8 = f32x8::splat(0.5);

/// Precomputed sRGB u8 → linear f32 lookup table.
/// Uses the same constants as the transfer module (C0-continuous IEC 61966-2-1).
/// Generated by computing `srgb_u8_to_linear(i)` for each i in 0..=255.
/// To regenerate: `cargo run --release --example generate_lut`
const SRGB_U8_TO_LINEAR_LUT: [f32; 256] = [
    0.0_f32,
    0.000303527_f32,
    0.000607054_f32,
    0.000910581_f32,
    0.001214108_f32,
    0.001517635_f32,
    0.001821162_f32,
    0.0021246888_f32,
    0.002428216_f32,
    0.002731743_f32,
    0.00303527_f32,
    0.0033473307_f32,
    0.0036773437_f32,
    0.0040255957_f32,
    0.004392362_f32,
    0.004777916_f32,
    0.0051825214_f32,
    0.00560644_f32,
    0.006049924_f32,
    0.0065132244_f32,
    0.0069965874_f32,
    0.007500253_f32,
    0.008024457_f32,
    0.008569433_f32,
    0.009135411_f32,
    0.009722613_f32,
    0.010331264_f32,
    0.010961577_f32,
    0.011613773_f32,
    0.012288062_f32,
    0.012984648_f32,
    0.013703744_f32,
    0.01444555_f32,
    0.015210266_f32,
    0.01599809_f32,
    0.016809216_f32,
    0.01764384_f32,
    0.018502146_f32,
    0.019384334_f32,
    0.02029058_f32,
    0.02122107_f32,
    0.022175988_f32,
    0.023155512_f32,
    0.024159823_f32,
    0.025189094_f32,
    0.026243499_f32,
    0.027323212_f32,
    0.0284284_f32,
    0.02955924_f32,
    0.030715894_f32,
    0.03189852_f32,
    0.0331073_f32,
    0.034342386_f32,
    0.03560393_f32,
    0.036892105_f32,
    0.03820707_f32,
    0.039548974_f32,
    0.04091798_f32,
    0.04231424_f32,
    0.04373789_f32,
    0.045189105_f32,
    0.04666803_f32,
    0.04817481_f32,
    0.049709592_f32,
    0.051272515_f32,
    0.052863743_f32,
    0.054483414_f32,
    0.05613167_f32,
    0.05780865_f32,
    0.05951448_f32,
    0.061249338_f32,
    0.063013345_f32,
    0.06480663_f32,
    0.06662934_f32,
    0.068481594_f32,
    0.07036356_f32,
    0.072275355_f32,
    0.07421711_f32,
    0.07618896_f32,
    0.07819102_f32,
    0.080223456_f32,
    0.08228638_f32,
    0.08437992_f32,
    0.086504206_f32,
    0.088659346_f32,
    0.09084551_f32,
    0.093062796_f32,
    0.09531133_f32,
    0.09759124_f32,
    0.09990266_f32,
    0.10224568_f32,
    0.104620464_f32,
    0.10702711_f32,
    0.109465756_f32,
    0.1119365_f32,
    0.11443946_f32,
    0.116974786_f32,
    0.11954258_f32,
    0.12214295_f32,
    0.12477602_f32,
    0.1274419_f32,
    0.13014072_f32,
    0.1328726_f32,
    0.13563763_f32,
    0.13843594_f32,
    0.14126763_f32,
    0.14413282_f32,
    0.14703165_f32,
    0.1499642_f32,
    0.15293059_f32,
    0.15593089_f32,
    0.15896529_f32,
    0.16203386_f32,
    0.1651367_f32,
    0.16827393_f32,
    0.17144562_f32,
    0.17465195_f32,
    0.17789298_f32,
    0.18116882_f32,
    0.1844796_f32,
    0.18782537_f32,
    0.1912063_f32,
    0.19462249_f32,
    0.19807397_f32,
    0.2015609_f32,
    0.20508343_f32,
    0.20864154_f32,
    0.21223548_f32,
    0.21586527_f32,
    0.21953095_f32,
    0.22323275_f32,
    0.22697066_f32,
    0.23074481_f32,
    0.2345554_f32,
    0.23840237_f32,
    0.24228595_f32,
    0.24620613_f32,
    0.25016314_f32,
    0.25415692_f32,
    0.25818765_f32,
    0.26225552_f32,
    0.26636043_f32,
    0.27050266_f32,
    0.27468216_f32,
    0.27889907_f32,
    0.2831536_f32,
    0.28744566_f32,
    0.29177552_f32,
    0.2961431_f32,
    0.30054858_f32,
    0.30499217_f32,
    0.30947372_f32,
    0.31399357_f32,
    0.3185516_f32,
    0.32314798_f32,
    0.3277829_f32,
    0.33245632_f32,
    0.33716843_f32,
    0.34191918_f32,
    0.34670877_f32,
    0.35153738_f32,
    0.35640487_f32,
    0.36131153_f32,
    0.3662573_f32,
    0.37124234_f32,
    0.37626684_f32,
    0.38133067_f32,
    0.3864341_f32,
    0.39157712_f32,
    0.3967598_f32,
    0.4019824_f32,
    0.40724477_f32,
    0.4125472_f32,
    0.41788962_f32,
    0.42327216_f32,
    0.42869502_f32,
    0.4341581_f32,
    0.43966165_f32,
    0.44520563_f32,
    0.45079017_f32,
    0.4564154_f32,
    0.46208134_f32,
    0.46778816_f32,
    0.4735358_f32,
    0.47932443_f32,
    0.4851542_f32,
    0.49102503_f32,
    0.49693722_f32,
    0.5028906_f32,
    0.5088854_f32,
    0.5149218_f32,
    0.5209996_f32,
    0.52711916_f32,
    0.5332804_f32,
    0.53948337_f32,
    0.5457284_f32,
    0.55201524_f32,
    0.55834424_f32,
    0.56471527_f32,
    0.57112855_f32,
    0.57758415_f32,
    0.58408207_f32,
    0.5906225_f32,
    0.59720534_f32,
    0.6038308_f32,
    0.6104991_f32,
    0.61721_f32,
    0.62396383_f32,
    0.6307605_f32,
    0.6376001_f32,
    0.644483_f32,
    0.6514088_f32,
    0.658378_f32,
    0.6653904_f32,
    0.67244613_f32,
    0.67954546_f32,
    0.68668824_f32,
    0.6938747_f32,
    0.7011047_f32,
    0.7083785_f32,
    0.7156962_f32,
    0.72305775_f32,
    0.7304634_f32,
    0.73791295_f32,
    0.7454066_f32,
    0.75294465_f32,
    0.76052684_f32,
    0.7681535_f32,
    0.7758244_f32,
    0.7835399_f32,
    0.79130006_f32,
    0.79910475_f32,
    0.80695426_f32,
    0.8148484_f32,
    0.82278764_f32,
    0.8307716_f32,
    0.83880067_f32,
    0.8468749_f32,
    0.8549941_f32,
    0.8631587_f32,
    0.8713685_f32,
    0.87962353_f32,
    0.8879244_f32,
    0.89627033_f32,
    0.9046623_f32,
    0.9130995_f32,
    0.9215827_f32,
    0.9301116_f32,
    0.93868643_f32,
    0.9473071_f32,
    0.9559739_f32,
    0.9646866_f32,
    0.9734457_f32,
    0.9822507_f32,
    0.9911024_f32,
    1.0_f32,
];

#[inline]
fn get_lut() -> &'static [f32; 256] {
    &SRGB_U8_TO_LINEAR_LUT
}

// ============================================================================
// x8 Functions - Process 8 values at once
// ============================================================================

/// Convert 8 sRGB f32 values to linear.
///
/// Input values are clamped to \[0, 1\].
///
/// # Example
/// ```
/// use linear_srgb::simd::srgb_to_linear_x8;
/// use wide::f32x8;
///
/// let srgb = f32x8::from([0.0, 0.25, 0.5, 0.75, 1.0, 0.1, 0.9, 0.5]);
/// let linear = srgb_to_linear_x8(srgb);
/// ```
#[multiversed]
#[inline]
pub fn srgb_to_linear_x8(srgb: f32x8) -> f32x8 {
    let srgb = srgb.max(ZERO).min(ONE);
    let linear_result = srgb * LINEAR_SCALE;
    let power_result = pow_x8((srgb + SRGB_OFFSET) / SRGB_SCALE, 2.4);
    let mask = srgb.simd_lt(SRGB_LINEAR_THRESHOLD);
    mask.blend(linear_result, power_result)
}

/// Convert 8 linear f32 values to sRGB.
///
/// Input values are clamped to \[0, 1\].
///
/// # Example
/// ```
/// use linear_srgb::simd::linear_to_srgb_x8;
/// use wide::f32x8;
///
/// let linear = f32x8::from([0.0, 0.1, 0.2, 0.5, 1.0, 0.01, 0.05, 0.8]);
/// let srgb = linear_to_srgb_x8(linear);
/// ```
#[multiversed]
#[inline]
pub fn linear_to_srgb_x8(linear: f32x8) -> f32x8 {
    let linear = linear.max(ZERO).min(ONE);
    let linear_result = linear * TWELVE_92;
    let power_result = SRGB_SCALE * pow_x8(linear, 1.0 / 2.4) - SRGB_OFFSET;
    let mask = linear.simd_lt(LINEAR_THRESHOLD);
    mask.blend(linear_result, power_result)
}

/// Convert 8 sRGB u8 values to linear f32 using LUT lookup.
///
/// This is the fastest method for u8 input as it uses a precomputed lookup table.
///
/// # Example
/// ```
/// use linear_srgb::simd::srgb_u8_to_linear_x8;
///
/// let srgb = [0u8, 64, 128, 192, 255, 32, 96, 160];
/// let linear = srgb_u8_to_linear_x8(srgb);
/// ```
#[inline]
pub fn srgb_u8_to_linear_x8(srgb: [u8; 8]) -> f32x8 {
    let lut = get_lut();
    f32x8::from([
        lut[srgb[0] as usize],
        lut[srgb[1] as usize],
        lut[srgb[2] as usize],
        lut[srgb[3] as usize],
        lut[srgb[4] as usize],
        lut[srgb[5] as usize],
        lut[srgb[6] as usize],
        lut[srgb[7] as usize],
    ])
}

/// Convert 8 linear f32 values to sRGB u8.
///
/// Input values are clamped to \[0, 1\], output is rounded to nearest u8.
///
/// # Example
/// ```
/// use linear_srgb::simd::linear_to_srgb_u8_x8;
/// use wide::f32x8;
///
/// let linear = f32x8::from([0.0, 0.1, 0.2, 0.5, 1.0, 0.01, 0.05, 0.8]);
/// let srgb = linear_to_srgb_u8_x8(linear);
/// ```
#[multiversed]
#[inline]
pub fn linear_to_srgb_u8_x8(linear: f32x8) -> [u8; 8] {
    let srgb = linear_to_srgb_x8(linear);
    let scaled = srgb * U8_MAX + HALF;
    let arr: [f32; 8] = scaled.into();
    [
        arr[0] as u8,
        arr[1] as u8,
        arr[2] as u8,
        arr[3] as u8,
        arr[4] as u8,
        arr[5] as u8,
        arr[6] as u8,
        arr[7] as u8,
    ]
}

// ============================================================================
// Slice Functions - Process entire slices
// ============================================================================

/// Convert sRGB f32 values to linear in-place.
///
/// Processes 8 values at a time using SIMD, with scalar fallback for remainder.
///
/// # Example
/// ```
/// use linear_srgb::simd::srgb_to_linear_slice;
///
/// let mut values = vec![0.0f32, 0.25, 0.5, 0.75, 1.0];
/// srgb_to_linear_slice(&mut values);
/// ```
#[multiversed]
#[inline]
pub fn srgb_to_linear_slice(values: &mut [f32]) {
    let (chunks, remainder) = values.as_chunks_mut::<8>();

    for chunk in chunks {
        let result = srgb_to_linear_x8(f32x8::from(*chunk));
        *chunk = result.into();
    }

    for v in remainder {
        *v = crate::srgb_to_linear(*v);
    }
}

/// Convert linear f32 values to sRGB in-place.
///
/// Processes 8 values at a time using SIMD, with scalar fallback for remainder.
///
/// # Example
/// ```
/// use linear_srgb::simd::linear_to_srgb_slice;
///
/// let mut values = vec![0.0f32, 0.1, 0.2, 0.5, 1.0];
/// linear_to_srgb_slice(&mut values);
/// ```
#[multiversed]
#[inline]
pub fn linear_to_srgb_slice(values: &mut [f32]) {
    let (chunks, remainder) = values.as_chunks_mut::<8>();

    for chunk in chunks {
        let result = linear_to_srgb_x8(f32x8::from(*chunk));
        *chunk = result.into();
    }

    for v in remainder {
        *v = crate::linear_to_srgb(*v);
    }
}

/// Convert sRGB u8 values to linear f32.
///
/// Uses a precomputed LUT for each u8 value, processed in SIMD batches of 8.
///
/// # Panics
/// Panics if `input.len() != output.len()`.
///
/// # Example
/// ```
/// use linear_srgb::simd::srgb_u8_to_linear_slice;
///
/// let input: Vec<u8> = (0..=255).collect();
/// let mut output = vec![0.0f32; 256];
/// srgb_u8_to_linear_slice(&input, &mut output);
/// ```
#[inline]
pub fn srgb_u8_to_linear_slice(input: &[u8], output: &mut [f32]) {
    assert_eq!(input.len(), output.len());
    let lut = get_lut();

    let (in_chunks, in_remainder) = input.as_chunks::<8>();
    let (out_chunks, out_remainder) = output.as_chunks_mut::<8>();

    for (inp, out) in in_chunks.iter().zip(out_chunks.iter_mut()) {
        *out = [
            lut[inp[0] as usize],
            lut[inp[1] as usize],
            lut[inp[2] as usize],
            lut[inp[3] as usize],
            lut[inp[4] as usize],
            lut[inp[5] as usize],
            lut[inp[6] as usize],
            lut[inp[7] as usize],
        ];
    }

    for (inp, out) in in_remainder.iter().zip(out_remainder.iter_mut()) {
        *out = lut[*inp as usize];
    }
}

/// Convert linear f32 values to sRGB u8.
///
/// Processes 8 values at a time using SIMD, with scalar fallback for remainder.
///
/// # Panics
/// Panics if `input.len() != output.len()`.
///
/// # Example
/// ```
/// use linear_srgb::simd::linear_to_srgb_u8_slice;
///
/// let input: Vec<f32> = (0..=255).map(|i| i as f32 / 255.0).collect();
/// let mut output = vec![0u8; 256];
/// linear_to_srgb_u8_slice(&input, &mut output);
/// ```
#[multiversed]
#[inline]
pub fn linear_to_srgb_u8_slice(input: &[f32], output: &mut [u8]) {
    assert_eq!(input.len(), output.len());

    let (in_chunks, in_remainder) = input.as_chunks::<8>();
    let (out_chunks, out_remainder) = output.as_chunks_mut::<8>();

    for (inp, out) in in_chunks.iter().zip(out_chunks.iter_mut()) {
        *out = linear_to_srgb_u8_x8(f32x8::from(*inp));
    }

    for (inp, out) in in_remainder.iter().zip(out_remainder.iter_mut()) {
        let srgb = crate::linear_to_srgb(*inp);
        *out = (srgb * 255.0 + 0.5) as u8;
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // ---- x8 function tests ----

    #[test]
    fn test_srgb_to_linear_x8() {
        let input = [0.0f32, 0.25, 0.5, 0.75, 1.0, 0.1, 0.9, 0.04];
        let result = srgb_to_linear_x8(f32x8::from(input));
        let result_arr: [f32; 8] = result.into();

        for (i, &inp) in input.iter().enumerate() {
            let expected = crate::srgb_to_linear(inp);
            assert!(
                (result_arr[i] - expected).abs() < 1e-5,
                "srgb_to_linear_x8 mismatch at {}: got {}, expected {}",
                i,
                result_arr[i],
                expected
            );
        }
    }

    #[test]
    fn test_linear_to_srgb_x8() {
        let input = [0.0f32, 0.1, 0.2, 0.5, 1.0, 0.01, 0.001, 0.8];
        let result = linear_to_srgb_x8(f32x8::from(input));
        let result_arr: [f32; 8] = result.into();

        for (i, &inp) in input.iter().enumerate() {
            let expected = crate::linear_to_srgb(inp);
            assert!(
                (result_arr[i] - expected).abs() < 1e-5,
                "linear_to_srgb_x8 mismatch at {}: got {}, expected {}",
                i,
                result_arr[i],
                expected
            );
        }
    }

    #[test]
    fn test_srgb_u8_to_linear_x8() {
        let input: [u8; 8] = [0, 64, 128, 192, 255, 32, 96, 160];
        let result = srgb_u8_to_linear_x8(input);
        let result_arr: [f32; 8] = result.into();

        for (i, &inp) in input.iter().enumerate() {
            let expected = crate::srgb_u8_to_linear(inp);
            assert!(
                (result_arr[i] - expected).abs() < 1e-6,
                "srgb_u8_to_linear_x8 mismatch at {}: got {}, expected {}",
                i,
                result_arr[i],
                expected
            );
        }
    }

    #[test]
    fn test_linear_to_srgb_u8_x8() {
        let input = [0.0f32, 0.1, 0.2, 0.5, 1.0, 0.01, 0.05, 0.8];
        let result = linear_to_srgb_u8_x8(f32x8::from(input));

        for (i, &inp) in input.iter().enumerate() {
            let expected = (crate::linear_to_srgb(inp) * 255.0 + 0.5) as u8;
            assert!(
                (result[i] as i16 - expected as i16).abs() <= 1,
                "linear_to_srgb_u8_x8 mismatch at {}: got {}, expected {}",
                i,
                result[i],
                expected
            );
        }
    }

    // ---- Slice function tests ----

    #[test]
    fn test_srgb_to_linear_slice() {
        let mut values: Vec<f32> = (0..100).map(|i| i as f32 / 99.0).collect();
        let expected: Vec<f32> = values.iter().map(|&v| crate::srgb_to_linear(v)).collect();

        srgb_to_linear_slice(&mut values);

        for (i, (&got, &exp)) in values.iter().zip(expected.iter()).enumerate() {
            assert!(
                (got - exp).abs() < 1e-5,
                "srgb_to_linear_slice mismatch at {}: got {}, expected {}",
                i,
                got,
                exp
            );
        }
    }

    #[test]
    fn test_linear_to_srgb_slice() {
        let mut values: Vec<f32> = (0..100).map(|i| i as f32 / 99.0).collect();
        let expected: Vec<f32> = values.iter().map(|&v| crate::linear_to_srgb(v)).collect();

        linear_to_srgb_slice(&mut values);

        for (i, (&got, &exp)) in values.iter().zip(expected.iter()).enumerate() {
            assert!(
                (got - exp).abs() < 1e-5,
                "linear_to_srgb_slice mismatch at {}: got {}, expected {}",
                i,
                got,
                exp
            );
        }
    }

    #[test]
    fn test_srgb_u8_to_linear_slice() {
        let input: Vec<u8> = (0..=255).collect();
        let mut output = vec![0.0f32; 256];

        srgb_u8_to_linear_slice(&input, &mut output);

        for (i, &out) in output.iter().enumerate() {
            let expected = crate::srgb_u8_to_linear(i as u8);
            assert!(
                (out - expected).abs() < 1e-6,
                "srgb_u8_to_linear_slice mismatch at {}: got {}, expected {}",
                i,
                out,
                expected
            );
        }
    }

    #[test]
    fn test_linear_to_srgb_u8_slice() {
        let input: Vec<f32> = (0..=255).map(|i| i as f32 / 255.0).collect();
        let mut output = vec![0u8; 256];

        linear_to_srgb_u8_slice(&input, &mut output);

        for i in 0..256 {
            let expected = (crate::linear_to_srgb(input[i]) * 255.0 + 0.5) as u8;
            assert!(
                (output[i] as i16 - expected as i16).abs() <= 1,
                "linear_to_srgb_u8_slice mismatch at {}: got {}, expected {}",
                i,
                output[i],
                expected
            );
        }
    }

    // ---- Roundtrip tests ----

    #[test]
    fn test_f32_roundtrip() {
        let mut values: Vec<f32> = (0..1000).map(|i| i as f32 / 999.0).collect();
        let original = values.clone();

        srgb_to_linear_slice(&mut values);
        linear_to_srgb_slice(&mut values);

        for (i, (&orig, &conv)) in original.iter().zip(values.iter()).enumerate() {
            assert!(
                (orig - conv).abs() < 1e-4,
                "f32 roundtrip failed at {}: {} -> {}",
                i,
                orig,
                conv
            );
        }
    }

    #[test]
    fn test_u8_roundtrip() {
        let input: Vec<u8> = (0..=255).collect();
        let mut linear = vec![0.0f32; 256];
        let mut back = vec![0u8; 256];

        srgb_u8_to_linear_slice(&input, &mut linear);
        linear_to_srgb_u8_slice(&linear, &mut back);

        for i in 0..256 {
            assert!(
                (input[i] as i16 - back[i] as i16).abs() <= 1,
                "u8 roundtrip failed at {}: {} -> {} -> {}",
                i,
                input[i],
                linear[i],
                back[i]
            );
        }
    }

    // ---- Edge case tests ----

    #[test]
    fn test_clamping() {
        // Test that out-of-range values are clamped
        let input = f32x8::from([-0.5, -0.1, 0.0, 0.5, 1.0, 1.5, 2.0, 10.0]);
        let result = srgb_to_linear_x8(input);
        let arr: [f32; 8] = result.into();

        assert_eq!(arr[0], 0.0, "negative should clamp to 0");
        assert_eq!(arr[1], 0.0, "negative should clamp to 0");
        assert!(arr[4] > 0.99 && arr[4] <= 1.0, "1.0 should stay ~1.0");
        assert!(arr[5] > 0.99 && arr[5] <= 1.0, "values > 1 should clamp");
    }

    #[test]
    fn test_linear_segment() {
        // Test values in the linear segment (< 0.04045)
        let input = f32x8::from([0.0, 0.01, 0.02, 0.03, 0.04, 0.005, 0.015, 0.035]);
        let result = srgb_to_linear_x8(input);
        let arr: [f32; 8] = result.into();
        let input_arr: [f32; 8] = input.into();

        for i in 0..8 {
            let expected = input_arr[i] / 12.92;
            assert!(
                (arr[i] - expected).abs() < 1e-6,
                "linear segment mismatch at {}: got {}, expected {}",
                i,
                arr[i],
                expected
            );
        }
    }

    /// Verify the const LUT stays in sync with the transfer function.
    /// This test will fail if the transfer constants are changed without regenerating the LUT.
    #[test]
    fn test_lut_matches_transfer_function() {
        let lut = get_lut();
        for i in 0..=255u8 {
            let expected = crate::srgb_u8_to_linear(i);
            let got = lut[i as usize];
            assert_eq!(
                got.to_bits(),
                expected.to_bits(),
                "LUT[{}] = {} ({:08x}) != srgb_u8_to_linear({}) = {} ({:08x}). \
                 LUT needs regeneration if transfer constants changed.",
                i,
                got,
                got.to_bits(),
                i,
                expected,
                expected.to_bits()
            );
        }
    }

    #[test]
    fn test_empty_slice() {
        let mut empty: Vec<f32> = vec![];
        srgb_to_linear_slice(&mut empty);
        assert!(empty.is_empty());

        let empty_u8: Vec<u8> = vec![];
        let mut empty_out: Vec<f32> = vec![];
        srgb_u8_to_linear_slice(&empty_u8, &mut empty_out);
    }

    #[test]
    fn test_non_multiple_of_8() {
        // Test slices that aren't multiples of 8
        for len in [1, 3, 7, 9, 15, 17, 100] {
            let mut values: Vec<f32> = (0..len).map(|i| i as f32 / len as f32).collect();
            let expected: Vec<f32> = values.iter().map(|&v| crate::srgb_to_linear(v)).collect();

            srgb_to_linear_slice(&mut values);

            for (i, (&got, &exp)) in values.iter().zip(expected.iter()).enumerate() {
                assert!(
                    (got - exp).abs() < 1e-5,
                    "len={} mismatch at {}: got {}, expected {}",
                    len,
                    i,
                    got,
                    exp
                );
            }
        }
    }
}
